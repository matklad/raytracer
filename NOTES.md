Цвет float RGB, где все значения в `[0, 1]`.

От объекта:

* intersect with ray,
* normal vector at some point,
* colour at some point,
* material.

Для каждого объекта: форма, материал (один для объекта) и положение в пространстве.

```haskell
class Shape a where
  ...
```

Объекты:

* сфера (центр, радиус),
  - пересечение Леша уже написал
  - нормаль, соединить центр с точкой в которой надо построить нормаль и
    нормировать получившийся вектор
  - цвет в точке == цвет всей сферы
* плоскость (точка и нормаль к плоскости),
  - пересечение с лучем КО
  - нормаль у нас уже есть из определения
  - цвет аналогично сфере
* односторонний треугольник (три точки)
  - алгоритм Брезенхема для пересечения луча с треугольником
  - нормаль получаем следующим образом: строим два вектора по трем точкам,
    нормаль -- их нормированное векторное произведение

Mesh -- массив троек точек, задающий трехмерную модель. В Obj для каждой точки треугольника
есть нормаль, мы для каждого треугольника берем среднее из этих трех.

Roadmap:

- реализовать тайпкласс Shape
- сделать сферу инстансом Shape, на материал можно пока забить, а цвет возвращать белый
- сцена берет камеру, объекты, для каждого луча, пропущеного через экран сцена будет
  находить ближайший объект, пересекающийся с лучем и отрисовывать цвет этой точки
- повторить процедуру для плоскости
- отрисовать пересечение плоскости вместе со сферой другого цвета
- потом можно переходить к освещении

```
                                        объект и точка пересечения с первым объектом
                                                   |   (передается в shade)
                                                   v
trace  :: Ray -> [SomeShape] -> Maybe (SomeShape, Vec Double)
shade  :: Ray -> (SomeShape, Vec Double) -> Colour

render :: Scene -> (Int, Int) -> Colour
render =
  let ray = applyCamera (Int, Int) ... in
  case trace ray shapes of
    Just ... -> shade ray ...
    Nothing  -> defaultColour
```
